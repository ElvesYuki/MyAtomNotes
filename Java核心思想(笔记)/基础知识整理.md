## Java基础

### 1、Map集合的遍历方式

​	1、遍历Map集合需要用到的方法

​		public Set<K> keySet()				:将Map所有的key封装到一个Set集合

​		public V get(Object key)			  :根据key(键)获取对应的value(值)

​		public Set<Map.entry<k,V>> entrySet() :获取的所有的键值对对象集合

​		public Collection<V> values		:将Map中所有的value封装到一个Collection体系的集合

​	2、遍历Map集合的几种方式

​		第一种：根据键找值方式遍历

​		第二种：获取所有的键值对对象集合，通过迭代器遍历

​		第三种：获取所有的键值对对象集合，通过增强for遍历

​		第四种：通过Map集合中的values方法，拿到所有的值

### 2、HashMap特性

​	1、Map集合的特点
​		Map是一个双列集合,将键映射到值的对象
​		Map集合的数据结构,只针对键有效,跟值没有关系
​		一个映射不能包含重复的键,每个键最多只能映射到一个值
​	2、HashMap集合的数据结构是什么?
​		哈希表结构:**数组+链表**
​			通过哈希表结构配合对象的**hashCode**和**equals**方法就可以保证键的唯一性。
​		建议:今后键的位置如果存储的是自定义类型,下要忘记重写hashCode和equals方法。
​	3、HashMap和Hashtable的区别是?
​		HashMap是jdk1.2版本出现的,允许存储null键和null值
​				不同步(线程下安全):效率高
 		Hashtable是jdk1.0版本出现的,不允许存储null键和null值
​				同步(线程安全的):效率低
​	4、问题扩展
​		jdk8版本之后,在哈希表结构中引入了二叉树
​			问题:二叉树的出现有什么好处?
​					提高了查询的效率

### 3、HanhMap 和 Hashtable 的区别

​		相同点：都是双列集合，一个键对应一个值；都是键不能重复，只可以重复。

​		不同点：HashMap 是线程不同步的， 可以储存 null 键 和 null 值。

​						Hashtable是线程同步的，不可以储存 null 键 和 null 值。

### 4、Java虚拟机中的内存模型

![](K:\MyAtomNotes\Java核心思想(笔记)\images\Java虚拟机中的内存模型.jpg)

​		虚拟机中内存分为五个模块，分别为

​				**栈内存**：方法[运行时]所进入的内存,里面还会存储程序的局部变量

​				**堆内存**：new出来的数据都会进入堆内存

​				**方法区**：字节码文件加载时所进入的内存

​				**本地方法区**：这块内存空间主要调用的是操作系统相关资源

​				**寄存器**：交给CPU进行使用的

​		**(运行叙述，重点)**：

虚拟机加载一个类，通过**类加载器**拿到它的字节码文件放到**方法区**，**静态区**有main()方法，main()方法**进栈**运行；要声明一个Student对象，需要先加载字节码文件，这时Student类的字节码文件进入**方法区**，**静态区**的属性**初始化**为null，然后有值则赋值；new关键字在**堆**中创建Student对象，并初始化属性值，获取**方法区**中**非静态区**的方法引用地址，将Student对象的引用传给**栈**中声明的Student对象 s  ；s对象属性赋值，用过引用找到队中的对象，并赋值属性，然后继续调用方法，通过引用找到方法区中的方法进行调用，方法**进栈**调用，调用结束，方法弹栈；继续下一个对象或者方法，main()方法结束，main()方法弹栈。

​		**多线程Java虚拟机内存模型**：

![](K:\MyAtomNotes\Java核心思想(笔记)\images\多线程Java虚拟机内存模型.jpg)

​		1、每一个线程都会有自己独立的栈内存空间；

​		2、堆内存中的数据，是被多个线程所共享的。

### 5、创建线程的几种方式

​		1、继承Thread类

​				extend Thread 复写 run() 方法，通过 start() 方法启动线程。

​				该类不可再继承其他类。

​		2、实现Runnable接口

​				重写run() 方法，创建 Thread 对象实例(共享的)，传参，调用 

​				通过 start() 方法启动线程

​		3、实现Callable接口

​				与实现Runnable方式基本相同，重写call() 方法 ，有返回值

​				有返回值 ， 通过 .get（） 方法拿到返回值。

​		4、线程池方式

​				一个容纳多个线程的容器

​		Lock接口比synchronized的优势是什么？

​		1、能够显示的获取和释放锁，锁的运用更灵活。

​		2、可以方便地实现公平锁。

​		公平锁：表示线程获取锁的顺序是按照线程加锁的顺序来进行分配的，即现进先出顺序。

​		非公平锁：一种获取锁的抢占机制，是随机拿到锁的，和公平锁不同，先来的不一定先拿到锁，这个方式可能造成某些线程一直拿不到锁。

### 6、多线程解决同步的问题

​		1、同步代码块

​		2、同步方法

​				普通方法锁对象是本身；

​				静态方法锁对象是本类字节码对象。

​		3、Lock锁方式

### 7、Java中wait方法和sleep方法的不同之处

​		wait：此方法来自于Object类，必须由锁对象进行调用；

​		sleep：此方法来自于Thread类，是Thread类的静态方法，可以类点名调用。

​		wait：

​				空参数：会让线程进入无限等待状态，进入无限等待后，必须由notify() 方法对其进行唤醒；

​						**重点**：

​								wait() 方法在等待过程中，释放锁对象。

​								sleep()方法在休眠过程中，不会释放锁对象。

​				有参数的：效果和sleep()方法类似。

## Javaweb

### 1、cookie 和 session 的区别和联系

​		1、cookie 数据都放在客户的浏览器上， session 数据放在 服务器上。

​		2、很多浏览器限制同一个站点保存的cookie数量，单个cookie保存的数据不能超过4K

​		3、由于cookie 放在本地，所以并不安全，可以分析本地的cookie进行cookie欺骗，

一些重要信息比如密码等应当使用session，因为是放在服务器上的。

​		4、session 会在服务器上保存一段时间，当访问量大时，给服务器造成很大压力，一些不敏感的信息就可以使用cookie。

​		5、session 会在浏览器关闭过一定时间自动销毁，也可以手动设置时间。

​		6、一般情况下，session生成的sessionId会保存在cookie中。

### 2、TCP 和 UDP 区别 ，对 HTTP 协议理解

​		**TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来。**

​		我们来看看这三次对话的简单过程：

1. 主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；

2. 主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；

3. 主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。

   面向非连接的UDP协议

   “面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。这与现在风行的手机短信非常相似：你在发短信的时候，只需要输入对方手机号就OK了。

   **UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！**

   UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实 “ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如， 在默认状态下，一次“ping”操作发送4个数据包。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一 个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。

   