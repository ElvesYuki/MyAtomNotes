# Java核心思想(读书笔记)

## 第1章 对象导论

## 第2章 一切都是对象

## 第3章 操作符

#### 	3.4 赋值

​		对于基本类型，是将内容直接复制过去；

​		对于引用类型，在为对象“赋值”的时候，实际上是对对象的引用，把对象的地址值分给了左边的变量。

![1561796895022](K:\MyAtomNotes\Java核心思想(笔记)\images\1561796895022.png)

上文中，

```
t1 =t2;
```

 已将t2 的地址值 赋给 t1 ，此时 t1 、t2 指向的是同一个对象，

```
t1.level = 27 ;
```

此时是将27 赋给 t1 、t2 共同指向的对象里的属性。

![1561797162089](K:\MyAtomNotes\Java核心思想(笔记)\images\1561797162089.png)

​		方法中，传递的参数是对象的地址值。

##### 3.5.1 一元加、减操作符

```
x = a * (-b);
y = a * (+b);
```

​		一元减号用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是他唯一的作用是**将较小类型的操作数提升为 int** 。

## 第 11 章 持有对象(集合、容器)

**11.1 泛型和类型安全的容器**

​		如果一个类没有显式的声明继承自哪个类，那么它自动地继承自Object。

​		通过使用泛型，就可以在**编译期**防止将错误的类型的对象放置到容器中。

​		在将元素从List中取出时,类型转换也不再是必需的了。因为List知道它保存的是什么类型,因此它会在**调用get()**时替你执行**转型**。

​		你可以将 Apple的子类型添加到被指定为保存 Apple对象的容器中。程序的输出是从 Object默认的 tostring()方法产生的,该方法**将打印类名,后面跟随该对象的散列码**的无符号十六进制表示(这个散列码是通过 hashcod()方法产生的)。你将在第17章中了解有关散列码的内容。

#### 11.2 基本概念

```
List<Apple> apples = new ArrayList<Apple>();
```

​		**向上转型**：目的是只如果你决定要去修改你的实现，你所需的只是在创建出的时候修改它；如果子类方法中有额外的方法就不能这样做，比如**List**就不能获得**LinkedList**中特有的方法。

​		**所有的Conllection都可以用foreach语法遍历**。

#### 11.4 容器的打印

​		本例使用了三种基本风格的Map: Hashmap、 Treemap和 Linkedhashmap。与 Hashset一样，

​		**Hashmap**也提供了最快的查找技术,也没有按照任何明显的顺序来保存其元素。

​		**Treemap**按照比较结果的升序保存键。

​		**LinkedHashmap**則按照插入顺序保存键,同时还保留了Hashmap的查询速度。

#### 11.9 set

​		**Set**具有与 **Collection**完全一样的接口,因此没有任何额外的功能,不像前面有两个不同的
List。实际上Set就是 Collection,只是行为不同。(这是继承与多态思想的典型应用:表现不同
的行为。)Set是基于对象的値来确定归属性的,而更加复杂的问题我们将在第17章中介绍。

​		出于速度原因的考虑, Hashset使用了散列一散列将在第17章中介绍。 Hash Set所维护的顺序与 Treeset或 Linkedhashset都不同,因为它们的实现具有不同的元素存储方式。 **Treeset**将元素存储在**红一黑树**数据结构中,而**Hashset**使用的是**散列函数**。 **Linkedhashlist**因为**查询速度**的原因也使用了**散列**,但是看起来它使用了链表来维护元素的插入顺序。

## 第 13 章 字符串

#### 13.4 String上的操作

​		当需要改变字符申的内容时, String类的方法都会返回一个新的String对象。同时,如果内容没有发生改变, Stringl的方法只是返回指向原对象的引用而已。这可以节约存储空间以及避免额外的开销

## 第 16 章 数组

​		数组与其他种类的容器之间的区别有三方面：效率、类型和保存基本类型的能力。

​		在Java中,数组是一种**效率最高**的存储和随机访问对象引用序列的方式。数组就是一个简单的**线性序列**,这使得元素访问非常快速。但是为这种速度所付出的代价是**数组对象的大小被固定**,并且**在其生命周期中不可改变**。你可能会建议使用 Arraylist(参见第11章),**它可以通过创建一个新实例,然后把旧实例中所有的引用移到新实例中,从而实现更多空间的自动分配。**尽管通常应该首选 Arraylist而不是数组,但是这种弹性需要开销,因此, Array List的效率比数组低很多。

## 第 21 章 并发(多线程)

