 

# MySQL高性能笔记

## 第一章  MySQL架构与历史





## 第二章  MySQl基准测试





## 第三章  服务器性能剖析





## 第四章  Schema与数据类型优化

### 4.1  选择优化的数据类型

####         数据库数据类型的设计：

1、更小通常更好(当然了)

2、简单就好

​		**整型**比字符串操作代价更低，因为字符集和校对规则(排序规则)使字符比较整型比较更复杂

​				使用**内建类型**(date,time,datetime)而不是字符串来存储时间

​				应该用**整型**来存储IP地址

3、尽量**避免NULL**

​		因为查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂，可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。

​		当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM里甚至还可能导致固定大小的索引(例如只有一个整数列的索引)变成可变大小的索引。

​		但性能优化时提升又不大，所以设计的时候考虑一下这点，真出问题再视情况而定。

##### 4.1.1  整数类型

​		整数和实数

​		1、整数：

​		可以使用：  TINYINT, SAMLLINT, MEDIUMINT, INT, BIGINT

​								8			16				24					32	64		位存储空间 

​		可表示 -2^(N-1)到2^(N-1)-1

​		可选UNSIGNED属性，表示不允许负值  ，**性能是一样的**

​		如： TINYINT.UNSIGNED 可以存储范围0~255, 而TINYINT 存储范围 -128~127

​		你的选择决定MySQL是怎么在内存和磁盘中保存数据的。然而，**整数计算一般使用64位的BIGINT整数**，即使在32位环境也是如此。(一些聚合函数例外，它们使用DECIMAL或DOUBLE进行计算)。



##### 4.1.2  实数类型

1、FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算，CPU支持原生浮点计算，所以明显更快。

2、DECIMAL支持精确计算，MySQL本身实现的，可以指定小数点前后所允许的最大位数，这回影响列的空间消耗。

3、MySQL使用DOUBLE作为内部浮点计算的类型。

4、尽量只在对小数进行精确计算时才使用DECIMAL——例如存储财务数据。

5、数据量较大的时候，可以考虑使用BIGINT代替DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。

##### 4.1.3  字符串类型

1、每个字符串列可以定义自己的字符集和排序规则，或者说校对规则(collation),这些东西会很大程度上影响性能。

2、VARCHAR 类型用于存储可变长字符创，需要使用1或2个额外字节记录字符串的长度。后续更新过程，如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，不同的存储引擎的处理方式是不一样的。例如，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。其他一些存储引擎也许从不在原数据位置更新数据。

3、下列情况下使用VARCHAR是合适的：

​		a.字符串列的长度比平均长度大很多；

​		b.列的更新很少，所以碎片不是问题；

​		c.使用了像UTF-8这样的复杂的字符集，每个字符都使用不同的字节数进行存储。

4、CHAR类型使定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQl会删除所有末尾空格(在MySQL4.1和更老版本中VARCHAR也是这样实现的——也就是说这些版本中CHAR和VARCHAR在逻辑上时一样的，区别只是在存储格式上)。CHAR值会根据需要采用空格进行填充以方便比较。

5、CHAR适合存储很短的字符串，或者所有值都接近同一个长度。

​		a.例如存储密码的MD5值；

​		b.对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片；

​		c.对于非常短的列，CHAR比VARCHAR在储存空间上也更有效率。

​				**慷慨时不明智的：**

​		使用VARCHAR(5)和VARCHAR(200)存储'hello'的空间开销是一样的。那么使用更短的列有什么优势吗？

​		事实证明有很大优势。更长的列会消耗更多的内存，因为MySQl通常会分配固定大小的内存块保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。

​		**所以最好的策略是只分配真正需要的空间。**

6、BLOB和TEXT都是为存储很大的数据而设计的字符创数据类型，分别采用二进制和字符方式存储。

7、使用枚举(ENUM)代替字符串雷类型



##### 4.1.4 日期和时间类型

MySQL可以使用许多类型来保存日期和时间值。MySQL能存储的最小时间粒度为秒(MariaDB支持微秒级别的时间类型)。

1、DATETIME 和 TIMESTAMP

2、DATETIME：这个类型能保存大范围的值，从1001年到9999年，精度为秒。他把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，**与时区无关**。使用8个字节的存储空间。

3、TIMESTAMP： 保存了从1970年1月1日午夜(格林威治标准时间)以来的秒数，它和UNIX时间戳相同。TIMESTAMP只使用4个字节的存储空间，因此它的范围比DATETIME小得多：只能表示从1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。

4、TIMESTAMP 显示的值也依赖于时区。MySQL服务器、操作系统，以及客户端链接都有时区设置。

5、除了特殊行为之外，通常也应该尽量使用TIMESTAMP，因为它比DATETIME空间效率更高。有时候人们会将Unix时间戳存储为整数值，但这不会带来任何收益。用整数保存时间戳的格式通常不方便处理，所以我们不推荐这么做。



##### 4.1.5 位数据类型

##### 

##### 4.1.6 选择标识符

​		为标识列选择合适的数据类型非常重要。

1、整数类型

​		整数通常是标识列最好的选择，因为它们很快并且可以使用AUTO_INCREMENT。

2、ENUM和SET类型

​		大部分情况避免这么做

3、字符串类型

​		如果可能，应该尽量避免使用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。尤其是在MyISAM表里使用字符串作为标识列时要特别小心。MyISAM默认对字符串使用压缩索引，这会导致查询慢得多。在我们的测试中，我们注意到最多有6倍性能的下降。

对于完全“随机”的字符串也需要多加注意，例如MD5()、SHA1()或者UUID()产生的字符串。这些随机函数生成的新值会任意分布在很大的空间内，这回导致INSERT以及一些SELECT语句变得很慢：

​		a.因为插入值会随机的写到索引的不同位置，所以使得INSERT语句更慢。这回导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。

​		b.SELECT语句会变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。

​		c.随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的访问局部性原理失效。如果整个数据集都一样的“热”，那么缓存任何一部分特定数据到内存都没有好处；如果工作集比内存大，缓存将会有很多刷新和不命中。

4、如果存储UUID值，则应该移除“_”符号；或者更好的做法是，用UNHEX()函数转换UUID值为16字节的数字，并且存储在一个BINARY(16)列中。检索时可以通过HEX()函数来格式化为十六进制格式。

##### 4.1.7 特殊类型数据

​		某些类型的数据并不直接与内置类型一直。

​		IPv4地址：人们常用VARCHAR(15)列来存储IP地址。然而，它们实际上是32位无符号整数，不是字符串。用小数点将地址分成四段的表示方法只是为了让人们阅读容易。所以应该用无符号整数存储IP地址。MySQL提供INET_AOTN()和INET_NTOA()函数在这两种表示方法之间转换。



## 第五章 创建高性能的索引













